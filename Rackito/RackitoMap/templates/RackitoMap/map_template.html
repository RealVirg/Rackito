{% extends 'RackitoMap/base_app.html' %}
{% load static %} {# Загружаем тег static #}

{% block title %}Карта Rackito{% endblock %}

{% block styles %}
    {{ block.super }} {# Включаем стили из базового шаблона (base_app.html), включая map_styles.css #}
    {# Подключаем CSS для Leaflet #}
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
     integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
     crossorigin=""/>
    {# Подключаем CSS для Tagify #}
    <link href="https://unpkg.com/@yaireo/tagify/dist/tagify.css" rel="stylesheet" type="text/css" />

    <style>
        /* Стили для формы создания точки */
        #point-creation-form-container {
            position: absolute; /* Позиционируем относительно карты или body */
            display: none; /* Скрыто по умолчанию */
            background-color: white;
            padding: 15px;
            border: 1px solid #ccc;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 1001; /* Выше контекстного меню */
            min-width: 300px; /* Минимальная ширина */
            max-width: 90vw; /* Максимальная ширина */
            /* Добавляем ограничение высоты и скролл */
            max-height: 80vh; /* Макс. высота - 80% высоты экрана */
            overflow-y: auto; /* Включить верт. скролл если содержимое больше max-height */
            /* Добавляем внутренний отступ снизу, чтобы кнопки не прилипали */
            padding-bottom: 60px; /* Отступ для кнопок */
        }
        #point-creation-form-container h4 {
            margin-top: 0;
            margin-bottom: 15px;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }
        /* Стили для полей формы (предполагается Bootstrap или похожий) */
        #point-creation-form-container .form-group {
            margin-bottom: 1rem;
        }
        #point-creation-form-container label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: bold;
        }
        #point-creation-form-container input[type="text"],
        #point-creation-form-container input[type="email"], /* Добавьте другие типы по необходимости */
        #point-creation-form-container textarea,
        #point-creation-form-container select {
            width: 100%;
            padding: 0.375rem 0.75rem;
            font-size: 1rem;
            line-height: 1.5;
            color: #495057;
            background-color: #fff;
            background-clip: padding-box;
            border: 1px solid #ced4da;
            border-radius: 0.25rem;
            transition: border-color .15s ease-in-out,box-shadow .15s ease-in-out;
        }
        #point-creation-form-container input[readonly] {
             background-color: #e9ecef; /* Стиль для readonly поля адреса */
             cursor: not-allowed;
        }
        #point-creation-form-container .form-check {
            margin-bottom: 0.5rem;
        }
        #point-creation-form-container .form-check-input {
            margin-right: 0.5rem;
        }
         /* Стили для кнопок */
         #point-creation-form-buttons {
            /* Позиционируем кнопки абсолютно внизу контейнера */
            position: absolute;
            bottom: 15px; /* Отступ от нижнего края */
            right: 15px; /* Отступ от правого края */
            left: 15px; /* Растянем по ширине для justify-content */
            /* Убираем верхний отступ, так как он уже есть через padding-bottom контейнера */
            margin-top: 0;
            /* Стили для выравнивания остаются */
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            /* Добавим фон, чтобы кнопки не были прозрачными над прокручиваемым контентом */
            background-color: white; /* Фон как у формы */
            padding-top: 10px; /* Небольшой отступ сверху кнопок */
        }
         #point-creation-form-buttons button {
            padding: 8px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        #point-creation-form-buttons .btn-save {
            background-color: #28a745; /* Зеленый */
            color: white;
        }
         #point-creation-form-buttons .btn-cancel {
            background-color: #dc3545; /* Красный */
            color: white;
        }
        /* Дополнительные стили для Tagify, если нужны (например, высота) */
        .tagify {
            --tag-inset-shadow-size: 1.1em;
            border: 1px solid #ced4da; /* Совмещаем с другими полями */
            min-height: calc(1.5em + 0.75rem + 2px); /* Примерно как у form-control */
            padding: 0.375rem 0.75rem;
            border-radius: 0.25rem;
        }
        .tagify__input {
            font-size: 1rem; /* Совмещаем с другими полями */
            line-height: 1.5;
        }
    </style>
{% endblock %}

{% block content %}
    {# Виджет выбора города поверх карты #}
    <div id="city-select-widget">
         <label for="city-select" style="display: block; margin-bottom: 5px; font-weight: bold;">Город:</label> {# Добавим label для ясности #}
         <select id="city-select">
             <option value="">Выберите город...</option> {# Начальная опция #}
             <!-- Опции будут добавлены динамически -->
         </select>
    </div>
    <div id="map"></div>

    {# Контейнер для формы создания точки (изначально скрыт) #}
    <div id="point-creation-form-container">
        <h4>Создать новую точку</h4>
        {# Форма с ручным рендерингом полей #}
        <form id="point-creation-form" method="post" novalidate> {# novalidate - отключаем HTML5 валидацию, полагаемся на Django #}
            {% csrf_token %}

            {# Скрытые поля координат #}
            {{ point_form.latitude }}
            {{ point_form.longitude }}

            {# Поле Адрес #}
            <div class="form-group">
                <label for="{{ point_form.address.id_for_label }}">{{ point_form.address.label }}</label>
                {{ point_form.address }}
                {% if point_form.address.help_text %}<small class="form-text text-muted">{{ point_form.address.help_text }}</small>{% endif %}
                {% for error in point_form.address.errors %}<div class="invalid-feedback d-block">{{ error }}</div>{% endfor %}
            </div>

            {# Поле Тип точки (теперь Select) #}
            <div class="form-group">
                <label for="{{ point_form.point_type.id_for_label }}">{{ point_form.point_type.label }}</label>
                {# Рендерим как select #}
                {{ point_form.point_type }}
                 {% if point_form.point_type.help_text %}<small class="form-text text-muted">{{ point_form.point_type.help_text }}</small>{% endif %}
                 {% for error in point_form.point_type.errors %}<div class="invalid-feedback d-block">{{ error }}</div>{% endfor %}
            </div>

             {# === Заменяем старые поля тегов на поле для Tagify === #}
             <div class="form-group">
                 <label for="{{ point_form.tags_input.id_for_label }}">{{ point_form.tags_input.label }}</label>
                 {# Tagify будет инициализирован на этом input #}
                 {{ point_form.tags_input }}
                 {% if point_form.tags_input.help_text %}<small class="form-text text-muted">{{ point_form.tags_input.help_text }}</small>{% endif %}
                 {% for error in point_form.tags_input.errors %}<div class="invalid-feedback d-block">{{ error }}</div>{% endfor %}
             </div>
             {# === Конец замены полей тегов === #}

             {# Поле Описание точки #}
             <div class="form-group">
                <label for="{{ point_form.popup_text.id_for_label }}">{{ point_form.popup_text.label }}</label>
                {{ point_form.popup_text }}
                {% if point_form.popup_text.help_text %}<small class="form-text text-muted">{{ point_form.popup_text.help_text }}</small>{% endif %}
                {% for error in point_form.popup_text.errors %}<div class="invalid-feedback d-block">{{ error }}</div>{% endfor %}
            </div>

             <div id="point-creation-form-buttons">
                 <button type="button" class="btn-cancel" onclick="hidePointCreationForm()">Отмена</button>
                 <button type="submit" class="btn-save">Сохранить</button>
             </div>
        </form>
    </div>
{% endblock %}

{% block scripts %}
    {{ block.super }} {# Включаем скрипты из базового шаблона, если они есть #}
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
     integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
     crossorigin=""></script>
    {# Подключаем JS для Tagify #}
    <script src="https://unpkg.com/@yaireo/tagify"></script>
    <script src="https://unpkg.com/@yaireo/tagify/dist/tagify.polyfills.min.js"></script>

    <script>
        // Находим селектор (он все еще имеет тот же ID)
        const citySelect = document.getElementById('city-select');
        let cityData = []; // Массив для хранения данных о городах
        const initialZoom = 11; // Начальный зум
        const defaultCoords = [55.7558, 37.6173]; // Координаты по умолчанию (Москва)

        // URL для получения точек (используем тег url)
        const pointsUrl = "{% url 'RackitoMap:get_map_points' %}";
        // URL для обратного геокодирования
        const reverseGeocodeUrl = "{% url 'RackitoMap:reverse_geocode_proxy' %}";
        // URL для сохранения новой точки (пока заглушка, нужно будет создать view и url)
        const savePointUrl = "{% url 'RackitoMap:map_view' %}"; // ЗАГЛУШКА!

        // URL для автодополнения тегов
        const tagAutocompleteUrl = "{% url 'RackitoMap:tag_autocomplete' %}";

        // Контейнер карты для изменения курсора
        const mapContainer = document.getElementById('map');

        // Инициализация карты
        var map = L.map('map').setView(defaultCoords, initialZoom);

        // Слой для маркеров точек
        var pointsLayer = L.layerGroup().addTo(map);

        // Возвращаем стандартный слой OpenStreetMap
        L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
            attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
        }).addTo(map);

        // --- Загрузка и отображение точек --- //

        async function loadAndDisplayPoints() {
            const bounds = map.getBounds();
            const url = new URL(pointsUrl, window.location.origin);
            url.searchParams.append('south', bounds.getSouth());
            url.searchParams.append('west', bounds.getWest());
            url.searchParams.append('north', bounds.getNorth());
            url.searchParams.append('east', bounds.getEast());

            console.log("Fetching points from:", url.toString()); // Для отладки

            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const points = await response.json();

                // Очищаем предыдущие маркеры
                pointsLayer.clearLayers();

                // Добавляем новые маркеры
                points.forEach(point => {
                    let markerIcon;
                    if (point.marker_icon_url) {
                        markerIcon = L.icon({
                            iconUrl: point.marker_icon_url,
                            iconSize: [32, 32], // Размер иконки (пример)
                            iconAnchor: [16, 32], // Точка привязки (низ по центру)
                            popupAnchor: [0, -32], // Смещение попапа
                            className: 'custom-map-marker-icon' // Добавляем класс для стилизации
                        });
                    } else {
                        // Используем иконку по умолчанию, если нет кастомной
                        markerIcon = L.icon({
                             iconUrl: "{% static 'leaflet/images/marker-icon.png' %}", // Путь к стандартной иконке
                             shadowUrl: "{% static 'leaflet/images/marker-shadow.png' %}",
                             iconSize: [25, 41],
                             iconAnchor: [12, 41],
                             popupAnchor: [1, -34],
                             shadowSize: [41, 41]
                        });
                    }

                    const marker = L.marker([point.lat, point.lon], { icon: markerIcon });

                    if (point.popup_text) {
                        marker.bindPopup(point.popup_text);
                    }

                    pointsLayer.addLayer(marker);
                });
                console.log(`Displayed ${points.length} points.`); // Для отладки
            } catch (error) {
                console.error("Не удалось загрузить или отобразить точки:", error);
            }
        }

        // Загрузка точек при инициализации и после перемещения карты
        map.on('load', loadAndDisplayPoints);
        map.on('moveend', loadAndDisplayPoints);

        // --- Логика выбора города (обновлена) --- //

        async function loadCities() {
             try {
                const response = await fetch("{% static 'cities_russia.json' %}");
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                cityData = await response.json();
                cityData.sort((a, b) => a.name.localeCompare(b.name, 'ru'));

                cityData.forEach((city, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = city.name;
                    citySelect.appendChild(option);
                });

                const moscowIndex = cityData.findIndex(city => city.name === "Москва");
                if (moscowIndex !== -1) {
                    citySelect.value = moscowIndex;
                    // Установка вида инициирует 'moveend', точки загрузятся автоматически
                    map.setView(cityData[moscowIndex].coords, initialZoom);
                } else {
                    citySelect.value = "";
                    // Если Москвы нет, точки загрузятся для вида по умолчанию через 'moveend'
                    // или 'load', если карта еще не загрузилась
                }
            } catch (error) {
                console.error("Не удалось загрузить города:", error);
            }
        }

        citySelect.addEventListener('change', function() {
            const selectedIndex = this.value;
            if (selectedIndex !== "" && cityData[selectedIndex]) {
                const coords = cityData[selectedIndex].coords;
                 // Установка вида инициирует 'moveend', точки загрузятся автоматически
                map.setView(coords, initialZoom);
            }
        });

        loadCities();

        // --- Изменение курсора при перетаскивании --- //
        if (mapContainer) {
            map.on('mousedown', function () {
                mapContainer.style.cursor = 'grabbing';
            });

            map.on('mouseup', function () {
                mapContainer.style.cursor = 'pointer';
            });
            // Также возвращаем курсор, если он покинул карту во время перетаскивания
            map.on('mouseout', function () {
                if (mapContainer.style.cursor === 'grabbing') {
                    mapContainer.style.cursor = 'pointer';
                }
            });
        }


        // --- Логика создания точки --- //

        const pointCreationFormContainer = document.getElementById('point-creation-form-container');
        const pointCreationForm = document.getElementById('point-creation-form');
        const latitudeInput = document.getElementById('id_latitude');
        const longitudeInput = document.getElementById('id_longitude');
        const addressInput = document.getElementById('id_address');
        // Находим input для тегов
        const tagsInput = document.getElementById('{{ point_form.tags_input.id_for_label }}');

        // === Инициализация Tagify ===
        let tagify = null; // Переменная для хранения экземпляра Tagify
        if (tagsInput) {
             tagify = new Tagify(tagsInput, {
                // Не используем whitelist напрямую, будем загружать динамически
                // whitelist: [],
                 userInput: true, // Разрешить ввод тегов, которых нет в списке
                dropdown: {
                    maxItems: 10,
                    enabled: 1, // Показывать дропдаун после ввода 1 символа
                    closeOnSelect: false, // Не закрывать после выбора (для добавления нескольких)
                    highlightFirst: true,
                    position: 'text', // Позиционировать под текстом
                    // fuzzySearch: false // Можно включить, если нужно нечеткое совпадение
                 },
                 // Отключим встроенные suggestions, так как используем внешний источник
                // enforceWhitelist: false, // Разрешить добавление не из списка
                 // Конфигурация для AJAX автодополнения
                 // Мы будем использовать колбэк 'input'
            });

            let currentRequestController = null; // Для отмены предыдущих запросов

            // Слушатель для подгрузки подсказок
             tagify.on('input', async (e) => {
                 const value = e.detail.value;
                 tagify.loading(true); // Показать индикатор загрузки

                // Отменяем предыдущий запрос, если он еще выполняется
                if (currentRequestController) {
                    currentRequestController.abort();
                }
                currentRequestController = new AbortController();

                try {
                     const response = await fetch(`${tagAutocompleteUrl}?query=${encodeURIComponent(value)}`, {
                         signal: currentRequestController.signal
                     });
                     if (!response.ok) {
                         throw new Error(`HTTP error! status: ${response.status}`);
                     }
                     const suggestions = await response.json();
                     tagify.whitelist = suggestions; // Обновляем whitelist динамически
                     tagify.loading(false).dropdown.show(value); // Показываем дропдаун с новыми данными

                } catch (error) {
                    if (error.name !== 'AbortError') { // Не логируем ошибки отмены
                        console.error('Ошибка загрузки подсказок тегов:', error);
                        tagify.loading(false);
                    }
                }
            });
        } else {
             console.error("Не удалось найти поле ввода тегов для Tagify.");
        }
        // === Конец инициализации Tagify ===

        let currentContextMenuLatLng = null;

        function startPointCreation(latlng, pageX, pageY) {
             hideContextMenu();
            // Сбрасываем Tagify при открытии формы
            if (tagify) {
                tagify.removeAllTags();
            }
             showPointCreationForm(latlng, pageX, pageY);
        }

        // Обновленная функция показа формы с улучшенным позиционированием
        function showPointCreationForm(latlng, pageX, pageY) {
             pointCreationForm.reset();
            if (tagify) { tagify.removeAllTags(); }
            latitudeInput.value = latlng.lat;
            longitudeInput.value = latlng.lng;
            addressInput.value = 'Загрузка адреса...';

            // Сначала показываем, чтобы получить размеры
            pointCreationFormContainer.style.visibility = 'hidden'; // Скрываем через visibility
            pointCreationFormContainer.style.display = 'block';
            const formRect = pointCreationFormContainer.getBoundingClientRect();
            const bodyRect = document.body.getBoundingClientRect(); // Используем body или другой контейнер
            const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
            const viewportWidth = bodyRect.width - scrollbarWidth; // Реальная ширина видимой области
            const viewportHeight = window.innerHeight; // Высота видимой области

            const margin = 10; // Отступ от краев экрана и курсора

            // Рассчитываем позицию по горизонтали (left)
            let left = pageX + margin;
            if (left + formRect.width + margin > viewportWidth) { // Если уходит за правый край
                left = pageX - formRect.width - margin; // Попробовать слева от курсора
            }
             left = Math.max(margin, left); // Не даем уйти за левый край
             left = Math.min(left, viewportWidth - formRect.width - margin); // Дополнительно убедимся, что правый край не уходит

            // Рассчитываем позицию по вертикали (top)
            let top = pageY + margin;
            if (top + formRect.height + margin > viewportHeight) { // Если уходит за нижний край
                top = viewportHeight - formRect.height - margin; // Прижать к нижнему краю
            }
            top = Math.max(margin, top); // Не даем уйти за верхний край

            pointCreationFormContainer.style.left = `${left}px`;
            pointCreationFormContainer.style.top = `${top}px`;
            pointCreationFormContainer.style.visibility = 'visible'; // Делаем видимым

            fetchAddress(latlng.lat, latlng.lng);
            setTimeout(() => { document.addEventListener('click', handleClickOutsideForm, true); }, 0);
        }

        function hidePointCreationForm() {
            if (pointCreationFormContainer.style.display !== 'none') {
                pointCreationFormContainer.style.display = 'none';
                pointCreationForm.reset();
                // Сбрасываем Tagify при закрытии
                if (tagify) {
                    tagify.removeAllTags();
                }
                document.removeEventListener('click', handleClickOutsideForm, true);
            }
        }

        // Обработчик клика для закрытия формы, если клик был вне её
        function handleClickOutsideForm(event) {
            if (pointCreationFormContainer && !pointCreationFormContainer.contains(event.target)) {
                // Дополнительная проверка: не был ли клик на самом контекстном меню
                const contextMenu = document.getElementById('custom-context-menu');
                if (!contextMenu || !contextMenu.contains(event.target)) {
                     hidePointCreationForm();
                }
            }
        }

        // Функция для получения адреса по координатам
        async function fetchAddress(lat, lon) {
            const url = `${reverseGeocodeUrl}?lat=${lat}&lon=${lon}`;
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`Ошибка геокодирования: ${response.statusText}`);
                }
                const data = await response.json();
                // Используем display_name или собираем адрес из частей
                const address = data.display_name || `${data.address?.road || ''} ${data.address?.house_number || ''}, ${data.address?.city || data.address?.town || data.address?.village || ''}`;
                addressInput.value = address.trim().replace(/^, |, $/g, ''); // Очищаем возможные лишние запятые
            } catch (error) {
                console.error("Ошибка при получении адреса:", error);
                addressInput.value = 'Не удалось получить адрес';
            }
        }

        // Обработчик отправки формы (обновлен для Tagify)
        pointCreationForm.addEventListener('submit', async function(event) {
            event.preventDefault();
            console.log("Form submitted (AJAX simulation)");

            // Убедимся, что значение tagsInput обновлено из Tagify
            // Tagify автоматически обновляет значение оригинального <input>
            // Его значение по умолчанию - JSON-строка вида '[{"value":"tag1"},{"value":"tag2"}]'
            console.log("Tagify value in input:", tagsInput.value);

            // TODO: Реализовать AJAX отправку данных на сервер (savePointUrl)
            alert("Отправка формы пока не реализована. Данные в консоли.");
            const formData = new FormData(pointCreationForm);
            console.log("Form Data:", Object.fromEntries(formData.entries()));

            hidePointCreationForm();
            loadAndDisplayPoints();
        });

        // --- Пользовательское контекстное меню (обновлено) --- //
        let customContextMenu = null; // Переменная для хранения меню

        function createContextMenu() {
            if (customContextMenu) return;

            customContextMenu = document.createElement('div');
            customContextMenu.id = 'custom-context-menu';
            customContextMenu.style.position = 'absolute';
            customContextMenu.style.display = 'none';
            customContextMenu.style.zIndex = '1000';
             customContextMenu.style.background = 'white';
             customContextMenu.style.border = '1px solid #ccc';
             customContextMenu.style.padding = '5px 0';
             customContextMenu.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)';


            const createPointButton = document.createElement('button');
            createPointButton.textContent = 'Создать новую точку';
            createPointButton.id = 'create-point-btn';
            // Стили для кнопки меню
             createPointButton.style.display = 'block';
             createPointButton.style.width = '100%';
             createPointButton.style.padding = '8px 15px';
             createPointButton.style.border = 'none';
             createPointButton.style.background = 'none';
             createPointButton.style.textAlign = 'left';
             createPointButton.style.cursor = 'pointer';
             createPointButton.onmouseover = () => createPointButton.style.backgroundColor = '#f0f0f0';
             createPointButton.onmouseout = () => createPointButton.style.backgroundColor = 'white';

            createPointButton.onclick = function() {
                if (currentContextMenuLatLng) {
                     // Получаем координаты страницы из события, сохраненного при показе меню
                    const pageX = parseInt(customContextMenu.style.left.replace('px','')); // Преобразуем в число
                    const pageY = parseInt(customContextMenu.style.top.replace('px','')); // Преобразуем в число
                    // Вызываем startPointCreation, которая уже содержит hideContextMenu()
                    startPointCreation(currentContextMenuLatLng, pageX, pageY);
                } else {
                    console.error("Не удалось получить координаты для создания точки.");
                    hideContextMenu(); // Скрываем меню в случае ошибки
                }
                // hideContextMenu() теперь вызывается внутри startPointCreation или при ошибке
            };

            customContextMenu.appendChild(createPointButton);
            document.body.appendChild(customContextMenu);
        }

        // Обновленная функция показа меню
        function showContextMenu(event) {
            createContextMenu();
            hidePointCreationForm(); // Скрываем форму создания точки, если она была открыта
            currentContextMenuLatLng = event.latlng; // Сохраняем координаты карты
            const point = event.originalEvent;
            customContextMenu.style.left = `${point.pageX}px`;
            customContextMenu.style.top = `${point.pageY}px`;
            customContextMenu.style.display = 'block';
        }

        function hideContextMenu() {
            if (customContextMenu) {
                customContextMenu.style.display = 'none';
            }
             // Не сбрасываем currentContextMenuLatLng здесь, он нужен кнопке
        }

        // Обработчик правого клика на карте
        map.on('contextmenu', function(e) {
            e.originalEvent.preventDefault();
            showContextMenu(e);
        });

        // Скрываем меню и форму при клике левой кнопкой на карте (кроме клика внутри формы)
        map.on('click', function(e){
            // Не скрываем контекстное меню здесь, оно скроется само при клике на его кнопки
            // или при клике вне него/формы (см. handleClickOutsideForm)
            // hideContextMenu(); // Убираем это, чтобы меню не исчезало до выбора действия

            // Скрываем форму, если клик был не внутри неё (обработчик handleClickOutsideForm сделает это)
        });

        // Скрываем меню и форму при начале перемещения карты
        map.on('dragstart', () => { // Используем dragstart вместо movestart
            hideContextMenu();
            hidePointCreationForm();
        });

        // Скрываем меню и форму при начале изменения масштаба
        map.on('zoomstart', () => {
            hideContextMenu();
            hidePointCreationForm();
        });

        // --- Обратное геокодирование по клику (оставляем закомментированным) --- //
        /*
        map.on('click', function(e) {
           // ... (старый код) ...
        });
        */

    </script>
{% endblock %} 